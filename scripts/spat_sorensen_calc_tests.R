library(vegan)

setwd('~/maxent/spat')

source('./scripts/spat_sim_vario_func.R')

## simulated random matrices of abundance and examine if the expections
## generated by the sorExp function is correct


S = 50   ## number of species
nbar = 2    ## mean number of individuals per species 
N = 200      ## number of quadrats

comm_mat = replicate(S, rpois(N, lambda = 1))
abu = apply(comm_mat, 2, sum)
numOcc = apply(comm_mat > 0, 2, sum)
  
## for a single simulation 
## examine if spAvgExpPoi and spAvgExpBin are working correctly
get_avg_SR = function(mat, N, size, reps) {
  if (size == 1) {
    sim = replicate(reps, sum(mat[sample(N, size=1), ] > 0))
    sim_avg = mean(sim)
    sim_qt = quantile(sim, c(.025, .975))
  }  
  else {
    sim = replicate(reps, sum(apply(mat[sample(N, size=size), ] > 0, 2, sum) > 0))
    sim_avg = mean(sim)
    sim_qt = quantile(sim, c(.025, .975))
  }  
  return(c(sim_avg, sim_qt))
}

expSRabu = sapply(1:N, function(x) spAvgExpPoi(x/N, x/N, abu))
expSRbin = sapply(1:N, function(x) spAvgExpBin(x/N, x/N, N, numOcc))
obsSR = sapply(1:N, function(x) get_avg_SR(comm_mat, N, x, 1e3))

pdf('./figs/rpm_abu_bin_expSR_test.pdf')
  plot(obsSR[1,], ylim=range(c(expSRabu, expSRbin, obsSR)), type='o', xlim=c(1,10))
  lines(obsSR[2,])
  lines(obsSR[3,])
  lines(expSRabu, col='red')
  lines(expSRbin, col='blue')
  legend('bottomright', c('obsSR', 'expSR abu', 'expSR bin'), col=c(1, 'red', 'blue'),
         lty=1, bty='n')
dev.off()
  
## the above test demonstrates that spAvgExpPoi and spAvgExpBin are correct

## examine if spCommExpPoi and spCommExpBin are working correctly
## should return the expected number of species in common
get_avg_Comm = function(mat, reps) {
  sim = replicate(reps, sum(apply(mat[sample(N, size=2), ] > 0 , 2, sum) == 2))
  sim_mean = mean(sim)
  sim_qt = quantile(sim, c(.025, .975))
  return(c(sim_mean, sim_qt))
}

expCommAbu = spCommExpPoi(1/N, 1/N, abu)
expCommBin = spCommExpBin(1/N, 1/N, N, numOcc)
obsComm = get_avg_Comm(comm_mat, 1e3)

expCommAbu - obsComm[1]
expCommBin - obsComm[1]

pdf('./figs/rpm_abu_bin_Comm_test.pdf')
  plot(rep(1,3), obsComm, type='n', axes=F, xlab='', ylab='Commonality')
  axis(side=2)
  arrows(1, obsComm[2], 1, obsComm[3], angle=90, length=.1, code=3)
  points(1, obsComm[1])
  points(1, expCommAbu, col='red')
  points(1, expCommBin, col='blue')
  legend('bottomright', c('obsSR', 'expSR abu', 'expSR bin'), col=c(1, 'red', 'blue'),
         pch=1, lty=c(1, NA, NA), bty='n')
dev.off()

## that is a reasonable margin of error, so spCommExpPoi and spCommExpBin are correct

## now lets examine the spatial patterns within this simulated community for
## both the abundance and binary communities - examine if the permutation
## routine fits well with the overall community mean

## first check abundance permutation scheme
coords = cbind(1, 1:N)
comms = cbind(1, coords, comm_mat)
metrics = calcMetrics(comms, 'sorensen', 'abu', nperm = 500, npar=1)

qts_abu =1 - apply(metrics[[1]]$sorensen$sorensenNull$vario[ , , -1], 1:2,
                   quantile, c(.025, .5, .975))[ , ,1]

pdf('./figs/rpm_abu_perm_test.pdf')
  plot(metrics[[1]]$sorensen$sorensenNull$vdists, qts_abu[1,], 
       xlab='distance', ylab='sorensen similarity',
       ylim=range(as.vector(qts_abu)), type='l')
  lines(metrics[[1]]$sorensen$sorensenNull$vdists, qts_abu[2,])
  lines(metrics[[1]]$sorensen$sorensenNull$vdists, qts_abu[3,])
  lines(lowess(dist(coords), 1- vegdist(comm_mat)), lty=2)
  abline(h=1 - mean(vegdist(comm_mat)), col='green3')
  abline(h=sorExp(comm_mat, 1), col='red')
  legend('bottomright', c('permutation','overall mean', 'lowess'),
         col=c(1, 'green3', 1), lty=c(1,1,2), bg='white')
dev.off()

## these results suggest the permutation scheme is working properly
## the overall mean of the distance metric is right in line with 
## the lowess line which demonstrates that the observed community is 
## truely random in space, furthermore, the permutation result is right
## in line with the overall mean and lowess lines.  

## now check binary permutation scheme
comms = cbind(1, coords, (comm_mat > 0) *1)
metrics = calcMetrics(comms, 'sorensen', 'binary', nperm = 500, npar=1)

qts_bin = 1- apply(metrics[[1]]$sorensen$sorensenNull$vario[ , , -1], 1:2,
                   quantile, c(.025, .5, .975))[ , ,1]

pdf('./figs/rpm_binary_perm_test.pdf')
  plot(metrics[[1]]$sorensen$sorensenNull$vdists, qts_bin[1,], 
       ylim=range(as.vector(qts_bin)), type='l',
       xlab = 'Distance', ylab='Sorensen Similarity')
  lines(metrics[[1]]$sorensen$sorensenNull$vdists, qts_bin[2,])
  lines(metrics[[1]]$sorensen$sorensenNull$vdists, qts_bin[3,])
  lines(lowess(dist(coords),1- vegdist(comm_mat > 0)), lty=2)
  abline(h=1 - mean(vegdist(comm_mat > 0)), col='green3')
  abline(h=sorExp(comm_mat, 1), col='red')
  abline(h=sorExp(comm_mat > 0, 1), col='blue')
  legend('bottomright', 
         c('permutation','overall mean', 'lowess', 'exp abu', 'exp bin'),
         col=c(1, 'green3', 1, 'red', 'blue'), lty=c(1,1,2), bg='white')
dev.off()

## These results do not look as enouraging.  There are several problems
## with these results
## 1) the lowess line is shifted above the overall mean and permutation median
## 2) the expected sorensen metrics are above the overall mean and permutation
## medium, the exp binary is even higher than the exp abundance.  These expected
## values are still within the 95% confidence interval


## this indicates that if the function sorExp fails for abundance data
## then it is computing a quantity that is fundamentally different than the 
## quantity computed by vegdist(x)
## So what is the quantity calculated by the function vegdist for bray curtis
## with quantative data?

m = comm_mat[1:2, ]
sum(abs(m[1,] - m[2,])) / sum(m[1,] + m[2,])
vegdist(m, method='bray')
vegdist(m, method='bray', binary=TRUE)
m = (m > 0) * 1
sum(abs(m[1,] - m[2,])) / sum(m[1,] + m[2,])
## above can be verbally understood as
## total difference in abundance / total abundance
## or in a binary context
## number of species not in common / species in 1 + species in 2
## a: species in sample 1, b: species in sample 2, c: species in common
## a + b / a + b + 2c
## the similarity index is defined as
## 2c / a + b + 2c
sum((m[1,] + m[2,]) == 2) / mean(apply(m, 1, sum))
1 - vegdist(m, method='bray')

## so the formula listed in ?vegdist was accurate for what the function carries out
## the quantiative version is a direct extension of the binary version


S = 50   ## number of species
nbar = 1    ## mean number of individuals per species 
N = 1e2       ## number of quadrats
nSims = 500  ## number of simulations to run

resid_abu = rep(NA, nSims)
resid_bin = rep(NA, nSims)
for (i in 1:nSims) {
  comm_mat = replicate(S, rpois(N, lambda = 1))
  abu = apply(comm_mat, 2, sum)
#  exp_comm_abu = spCommExpPoi(1/N, 1/N, abu)
#  exp_sr_abu = spAvgExpPoi(1/N, 1/N, abu)
  exp_abu = sorExp(comm_mat, 1)
  exp_bin = sorExp(comm_mat > 0, 1)
  obs_sor = 1 - mean(vegdist(comm_mat > 0, method="bray"))
  resid_abu[i] = exp_abu - obs_sor 
  resid_bin[i] = exp_bin - obs_sor
}

pdf('./figs/rpm_residuals_abu_binary.pdf')
  par(mfrow=c(2,1))
  plot(density(resid_abu, na.rm=TRUE), xlab='Residual Sorensen Simiarlity',
       main='Results for 500 independent Poisson distributed communities',
       sub = 'Expected Sorensen from Abundance')
  plot(density(resid_bin, na.rm=TRUE), xlab='Residual Sorensen Similarity',
       main="", sub = 'Expected Sorense form Binary')
dev.off()

## the above plots show that both analytical calculations are positively
## biased of the expected sorensen. This is because the expected value of 
## the sorensen index is not truely equal to the ratio of two other expected
## values.  Plotkin and Muller-Landu touch on this in their paper.





